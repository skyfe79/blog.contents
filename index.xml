<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Burt.K</title><link>https://blog.burt.pe.kr/</link><description>Recent content on Burt.K</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><copyright>© Copyright Sungcheol Kim</copyright><lastBuildDate>Sun, 09 Feb 2020 09:52:48 +0900</lastBuildDate><atom:link href="https://blog.burt.pe.kr/index.xml" rel="self" type="application/rss+xml"/><item><title>아침걷기</title><link>https://blog.burt.pe.kr/talks/talks-2020-02-09-09-52/</link><pubDate>Sun, 09 Feb 2020 09:52:48 +0900</pubDate><guid>https://blog.burt.pe.kr/talks/talks-2020-02-09-09-52/</guid><description>햇살이 따사롭다. 겨울이 지나가고 봄이 오는 듯 하다. 그 동안 내 삶은 힘든 삶이었다. 왜 힘든지 이유도 모른채 끌려다니는 듯한 삶을 살아 왔다.
이제는 그 이유를 알 것 같다. 회사를 다닌 것 보다 내 회사를 만들고 싶다는 목표. 진정 원하는 목표를 위해 살지 못하니 살아감이 사는 것이 아니었다.
올해는 그 목표를 시작하려고 한다. 3월부터 홀로서기를 하게 되었다. 성공을 꿈꾸지는 않는다. 다만 오래 지속되는 회사를 만들고 싶다.
훗날 죽음을 생각하니, 내 일을 시작하지 않은 것을 가장 후회할 것 같았다.</description></item><item><title>아침걷기</title><link>https://blog.burt.pe.kr/talks/talks-2020-02-02-08-22/</link><pubDate>Sun, 02 Feb 2020 08:22:37 +0900</pubDate><guid>https://blog.burt.pe.kr/talks/talks-2020-02-02-08-22/</guid><description>오늘은 아침 날씨가 참 쌀쌀하다.
아침 하늘과 저녁 하늘이 만들어내는 그라데이션이 제일 아름답다.
수 없이 자란 풀이 마치 내 머릿속 수 많은 생각의 갈래처럼 느껴진다.</description></item><item><title>아침걷기</title><link>https://blog.burt.pe.kr/talks/talks-2020-02-01-08-30/</link><pubDate>Sat, 01 Feb 2020 08:30:26 +0900</pubDate><guid>https://blog.burt.pe.kr/talks/talks-2020-02-01-08-30/</guid><description>2020년을 맞이한 후 처음으로 아침걷기를 하였다. 날은 따뜻했다.
오랫만에 평온함을 느껴보는 아침이었다.
요즘은 커피를 줄이고 있어서 반환점을 돌아 바로 집으로 향했다. :)</description></item><item><title>Awesome Python</title><link>https://blog.burt.pe.kr/posts/awesome-python/</link><pubDate>Mon, 11 Nov 2019 23:39:57 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/awesome-python/</guid><description>내가 쓰는 파이썬 모듈 모음 :)</description></item><item><title>Jetpack Compose 첫느낌</title><link>https://blog.burt.pe.kr/posts/the-first-impression-of-jetpack-compose/</link><pubDate>Sun, 10 Nov 2019 22:11:47 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/the-first-impression-of-jetpack-compose/</guid><description>Android Studio 4.0 Canary 1이 배포된 이후로 Jetpack Compose에 대한 내용이 하나둘씩 채워지고 있다. Jetpack Compose에 대한 공식 튜토리얼이 나와서 따라해 보았다.
Jetpack Compose 공식 튜토리얼 우선은 SwiftUI와 비슷하게 Compose로 구성한 앱을 시뮬레이터나 디바이스에 직접 심지 않고 미리 보기를 통해 레이아웃을 확인할 수 있다. 미리 보기를 위해서 @Preview 어노테이션을 제공한다. 단, @Preview로 설정한 함수는 매개변수를 받을 수 없다. 매개변수가 필요한 @Compose함수라면 임의의 매개변수를 제공하여 미리 보기 함수를 구성해야 한다.</description></item><item><title>Go 로컬 패지키 모듈</title><link>https://blog.burt.pe.kr/posts/local-package-with-go-module/</link><pubDate>Sun, 10 Nov 2019 17:35:24 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/local-package-with-go-module/</guid><description>Go modules를 사용하면 $GOPATH를 신경쓰지 않고 Go 프로젝트를 시작할 수 있습니다. 이미 오픈되어 있는 Go모듈을 사용할 경우에는 아래처럼 go.mod파일에 패키지의 주소와 버전을 기입하면 패키지를 모듈로 사용할 수 있습니다.
module star go 1.13 require ( github.com/fogleman/gg v1.3.0 github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 // indirect golang.org/x/image v0.0.0-20191009234506-e7c1f5e7dbb8 // indirect ) 로컬패키지 그렇다면 로컬에 존재하는 패키지는 어떻게 go.mod파일에 기입할 수 있을까요? 아래와 같은 폴더 구조를 가지는 프로젝트를 생각해 보겠습니다.
hellogo ├── constants └── logics hellogo 폴더 하위에 모듈로 constants와 logics를 가지고 있습니다.</description></item><item><title>direvn로 $GOPATH 다루기</title><link>https://blog.burt.pe.kr/posts/handle-gopath-with-direnv/</link><pubDate>Sun, 10 Nov 2019 14:10:12 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/handle-gopath-with-direnv/</guid><description>Go언어를 아직 많이 사용해 본 것은 아니지만 go modules를 사용할 때 로컬 패키지 처리가 번거러운 것 같아서 $GOPATH를 다루는 쉬운 방법이 없을까 찾아 보았습니다. 그러던 중 direnv를 발견하여 관련 내용을 정리해 봅니다.
direnv direnv는 쉘의 환경 변수를 재정의하는 유틸리티입니다. Go언어는 $GOPATH를 워크스페이스마다 달리 설정해야 합니다. 하지만 매번 .bash_profile이나 .zshrc 같은 환경 파일을 편집해서 $GOPATH를 변경하는건 뭐랄까&amp;hellip; 음&amp;hellip;
파이썬에는 virtualenv같은 가상의 개발 환경을 만들어주는 도구가 존재하지만 Go언어는 그렇지 않습니다. 워크스페이스 폴더를 $GOPATH로 설정해 주어야 할 때 direnv를 사용하면 아주 편리합니다.</description></item><item><title>아침걷기</title><link>https://blog.burt.pe.kr/talks/talks-2019-11-09-10-30/</link><pubDate>Sat, 09 Nov 2019 10:30:29 +0900</pubDate><guid>https://blog.burt.pe.kr/talks/talks-2019-11-09-10-30/</guid><description>오늘은 날이 꽤 쌀쌀하다. 여름부터 해오던 아침걷기인데 벌써 겨울이 다가온다.
햇볕을 쬐는 갈대들이 황금색이다. 눈이 부시다 :)
요즘은 꾸준히 하지는 못하고 있지만ㅋㅋ 아침을 걷는 시간이 제일 편안하고 좋다.</description></item><item><title>출근길</title><link>https://blog.burt.pe.kr/talks/the-way-to-work-2019-11-05/</link><pubDate>Tue, 05 Nov 2019 23:07:15 +0900</pubDate><guid>https://blog.burt.pe.kr/talks/the-way-to-work-2019-11-05/</guid><description>나의 출근길은 기찻길로 시작된다. 안개와 산과 단풍이 어우러진 모습이 예뻐서 찍어 봤는데 사진은 별로 안 예쁘구나 ;)</description></item><item><title>저녁달리기</title><link>https://blog.burt.pe.kr/talks/jogging-2019-11-03/</link><pubDate>Mon, 04 Nov 2019 00:03:38 +0900</pubDate><guid>https://blog.burt.pe.kr/talks/jogging-2019-11-03/</guid><description>주말을 마무리 하면서 저녁달리기를 했다. 아침걷기를 하지 못하거나 몸이 좀 가벼워지고 싶을 때 저녁달리기를 한다. 달리기는 걷기와 달리 온전히 나에게 집중을 할 수 있다. 호흡을 조절해야 하기 때문이다. 뛰고 나면 흠뻑 젖는 등판과 이마의 땀이 불어오는 맞바람에 시원해지는 느낌이 좋다.</description></item><item><title>코틀린 코루틴 소개</title><link>https://blog.burt.pe.kr/posts/everything-you-need-to-know-about-kotlin-coroutines/</link><pubDate>Sun, 03 Nov 2019 23:50:17 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/everything-you-need-to-know-about-kotlin-coroutines/</guid><description>알림 이 글은 Everything you need to know about kotlin coroutines을 번역한 글임을 알려드립니다.
이 블로그 포스트의 목표는 다양한 코우틴 용어를 숙지하고 다음 질문에 답하는 것입니다.
Job과 Deferred, launch와 async의 차이점은 무엇인가? 어떤 코루틴 빌더를 사용해야 하는가? 코루틴에서 예외가 발생하면 어떻게 될까? 고수준의 구조화 된 동시성을 어떻게 만들 수 있을까? 변경 가능한 상태를 싱글스레드 디스패처를 사용해 스레드 안전하게 공유. 코루틴을 사용한 IO 및 CPU 바인딩 작업. 코루틴 작동 방식을 이해하고 실제 애플리케이션에서 효과적으로 사용하려면 핵심 개념을 먼저 이해해야 합니다.</description></item><item><title>Hello Go module, Goodbye GOPATH</title><link>https://blog.burt.pe.kr/posts/good-bye-gopath/</link><pubDate>Sat, 02 Nov 2019 20:14:00 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/good-bye-gopath/</guid><description>Go언어를 접하면서 $GOPATH를 설정하는 점이 약간 부담스러웠다. 그러나 1.13 이후 버전부터는 go module기능을 사용하여 $GOPATH이외의 위치에서 프로젝트를 생성할 수 있다.
시작하기 우선 프로젝트를 만들 폴더를 만든다. 예제로 AwesomeBin 폴더를 만들고 보자.
$ mkdir AwesomeBin $ cd AwesomeBin AwesomeBin 폴더에 진입한 다음에 우리가 만들 모듈의 이름. main package가 있는 곳이면 실행 파일의 이름으로 모듈을 초기화한다. awesome 실행파일이라고 가정해 보자.
$ go mod init awesome go: creating new go.mod: module awesome 그러면 go.</description></item><item><title>아침걷기</title><link>https://blog.burt.pe.kr/talks/talks-2019-11-02-12-23/</link><pubDate>Sat, 02 Nov 2019 12:23:37 +0900</pubDate><guid>https://blog.burt.pe.kr/talks/talks-2019-11-02-12-23/</guid><description>Hugo에 글을 쉽게 쓰는 법을 찾았다. 바로 메일앱을 사용하는 것이다. :) 생각이나 감정, 쓰고 싶은 생각을 메일로 적어 나에게 보내고 저녁에 취합해서 글로 올린다. 이렇게 적고 보니 비슷한 앱을 만들어도 좋을 것 같다.
오늘은 내 나무 친구를 소개하고 싶다. 이 친구를 만난 것은 여름이 끝나가고 가을이 다가올때 쯤이다. 수풀로 무성하던 들판을 정리하니 정말 멋진 나무가 있었다.
아침걷기를 하면 꼭 이 친구를 바라보고 온다. 매일 그 자리에 우뚝 서 있는 모습이 멋스럽다.</description></item><item><title>짧은 글쓰기</title><link>https://blog.burt.pe.kr/talks/short-writing/</link><pubDate>Sat, 02 Nov 2019 01:39:31 +0900</pubDate><guid>https://blog.burt.pe.kr/talks/short-writing/</guid><description>블로그를 오래전부터 만들고 관리해 왔지만 꾸준히 지속하여 글을 작성하진 못했다. 이전 블로그는 1년 가까이 방치하기도 하였다.
왜? 꾸준하게 글을 쓰지 못할까?
내가 내린 결론은 긴 글을 쓰려는 욕심 때문이다. 짧게 그리고 자주 글을 쓰기 위해서 talks 메뉴를 만들었다. 미디엄에서는 아침걷기와 책읽기 그리고 잡담을 위주로 짧은 글을 써 보았는데 꽤 자주 글을 쓸 수 있었다. 모바일앱이 있었던 미디엄과 달리 마크다운으로 글을 쓰고 커밋해야 하는 Hugo에서는 꾸준함을 지킬 수 있을지 궁금하다 :)</description></item><item><title>안녕하세요.</title><link>https://blog.burt.pe.kr/about/</link><pubDate>Sat, 02 Nov 2019 01:04:26 +0900</pubDate><guid>https://blog.burt.pe.kr/about/</guid><description/></item><item><title>모나드와 함수형 아키텍처 6장. 부록</title><link>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-6/</link><pubDate>Fri, 01 Nov 2019 23:00:32 +0900</pubDate><guid>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-6/</guid><description>6장. 부록 6-1. 타입 캐스팅 - C언어 타입 캐스팅이 위험한 이유 타입을 집합이라고 했을 때, C언어의 타입 캐스팅 연산자가 왜 위험한지 알 수 있습니다. 그리고 모던 프로그래밍 언어에는 타입 캐스팅 연산자가 왜 여러 개가 존재하는지 알 수 있습니다.
C언어의 타입 캐스팅은 아래와 같습니다.
int ch = (int)&amp;#39;a&amp;#39;; 문자형인 char 타입에서 정수형인 int 타입으로 타입 캐스팅을 하였습니다. C언어의 타입 캐스팅은 가장 강력하면서도 무식한 연산자입니다. 강력하면 좋을 것 같은데 왜 위험한 것일까요? 다음 예제를 보겠습니다.</description></item><item><title>모나드와 함수형 아키텍처 5장. 함수형 아키텍처</title><link>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-5/</link><pubDate>Fri, 01 Nov 2019 22:56:45 +0900</pubDate><guid>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-5/</guid><description>5장. 함수형 아키텍처 4부까지 모나드의 개념을 알아보고 몇 개의 간단한 모나드를 구현해 보았습니다. 이런 질문을 가질 수도 있습니다. 이렇게 배운 모나드 개념이 실제로 앱을 개발하거나 웹앱 그리고 백앤드 서비스 등을 만들 때 도움이 될 수 있을까? 5부에서는 이 질문에 대한 답을 찾아보려고 합니다.
5-1. 프론트앤드 아키텍처 윈도우 운영체제가 GUI 운영체제로 일반 사용자들에게 익숙해져 있을 때, 개발자들은 MFC와 델파이의 VCL 프레임워크를 사용하여 윈도우용 프로그램을 개발했습니다. MFC는 Win32 API를 C++로 추상화한 프레임워크로 마이크로소프트가 개발하였고 VCL은 Win32 API를 Turbo Pascal로 추상화한 프레임워크로 볼랜드가 개발하였습니다.</description></item><item><title>모나드와 함수형 아키텍처 4장. Monad 실전 예제</title><link>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-4/</link><pubDate>Fri, 01 Nov 2019 22:53:14 +0900</pubDate><guid>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-4/</guid><description>4장. Monad 실전 예제 4부에서는 1부, 2부, 3부에서 배운 이론을 바탕으로 여러 모나드를 만들어 보겠습니다. 구현언어로 Kotlin을 사용하겠습니다.
4-1. Optional Optional 모나드를 구현해 보겠습니다. Optional은 Swift, Kotlin에서 null이 가능한 타입입니다. 주로 Int? 처럼 구체타입에 ? 를 붙여서 표현합니다.
우선 타입과 map, flatMap을 정의합니다.
sealed class Optional&amp;lt;T&amp;gt; { class None&amp;lt;T&amp;gt;: Optional&amp;lt;T&amp;gt;() data class Some&amp;lt;T&amp;gt;(val value: T): Optional&amp;lt;T&amp;gt;() } infix fun &amp;lt;T, R&amp;gt; Optional&amp;lt;T&amp;gt;.map(functor: (value: T) -&amp;gt; R): Optional&amp;lt;R&amp;gt; { return this.flatMap { value -&amp;gt; Optional.</description></item><item><title>모나드와 함수형 아키텍처 3장. 모나드</title><link>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-3/</link><pubDate>Fri, 01 Nov 2019 22:43:36 +0900</pubDate><guid>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-3/</guid><description>3장. 모나드 $$ a \circ b \circ c \circ &amp;hellip; \circ x \circ y \circ z $$
함수 합성식입니다. 모나드뿐 아니라 함수형 프로그래밍의 본질이 모두 담겨 있는 식입니다. 사실 모든 이야기는 여기서부터 시작됩니다. 수학에서 이렇게 함수를 합성할 수 있는 이유는 수학의 함수가 순수 함수이기 때문입니다. 1부. 시작하기에서 함수는 두 집합을 연결하여 관계를 만들어 주는 연산으로 정의했습니다. 두 집합을 연결할 때 닫힘과 열림이라는 중요한 얘기를 해야 합니다.
3-1. 닫힘과 열림 집합 $A$에 대하여 이항연산을 수행할 때 연산 결과가 같은 집합 $A$의 원소이면 해당 이항연산은 집합 $A$에 닫혀 있다고 합니다.</description></item><item><title>모나드와 함수형 아키텍처 2장. 프로그래밍 패러다임</title><link>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-2/</link><pubDate>Fri, 01 Nov 2019 22:40:05 +0900</pubDate><guid>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-2/</guid><description>2장. 프로그래밍 패러다임 컴퓨터 프로그래밍 패러다임은 크게 구조적 프로그래밍, 객체지향 프로그래밍 그리고 함수형 프로그래밍으로 나눌 수 있습니다. 놀라운 사실은 이 패러다임들이 오래전에 모두 만들어졌다는 것입니다. 개발자들에게는 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍 순으로 인식되고 사용되어 온 것 같습니다. 그 이유는 소프트웨어의 크기와 컴퓨터의 성능 때문이라고 생각합니다. 각 패러다임에서 중요하게 생각했던 내용을 살펴보겠습니다.
2-1. 구조적 프로그래밍 구조적 프로그래밍이 주로 사용되던 시절은 컴퓨터 성능이 좋지 않았습니다. 그리고 통신의 속도도 빠르지 않았습니다. 통신 속도가 빠를수록 주고받는 데이터 또는 콘텐츠의 크기도 같이 커지기 마련입니다.</description></item><item><title>모나드와 함수형 아키텍처 1장. 시작하기</title><link>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-1/</link><pubDate>Fri, 01 Nov 2019 21:55:51 +0900</pubDate><guid>https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-1/</guid><description>안녕하세요. 데이블에서 모바일 서비스를 개발하고 있는 김성철입니다. 이 글은 모나드와 함수형 프로그래밍을 이해하기 위해서 지난 1년여간을 생각하고 정리한 내용을 담은 것입니다. 총 5장으로 구성되어 있으며 6장에는 글의 흐름과 약간 관련 없는 내용을 추가로 담고 있습니다. 어떤 부분은 부족할 것이고 어떤 부분은 과장 되었을지도 모릅니다. 그러나 모나드에 관한 글을 꼭 한번 써보고 싶었습니다. 모나드를 생각하고 정리하면서 저 자신도 많이 성장한 것 같습니다. 주실 피드백이 있으시다면 sungcheol@dable.io 또는 skyfe79@gmail.com으로 보내주세요.
1장. 시작하기 모나드를 얘기하기 전에 몇 가지를 정리하려고 합니다.</description></item><item><title>Hugo로 블로그 시작하기</title><link>https://blog.burt.pe.kr/posts/start-blog-with-hugo/</link><pubDate>Sat, 26 Oct 2019 13:57:42 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/start-blog-with-hugo/</guid><description>오랫동안 묵혀두었던 Jekyll 기반 블로그를 지우고 Hugo로 블로그를 열어 보았습니다. Hugo로 블로그를 개설할 때 다음 글에서 많은 도움을 받았습니다.
테마 Hugo 로 github 블로그 시작하기 TRAVIS CI 를 이용해서 HUGO 기반 웹사이트 배포 하기 Hosting a Hugo blog on GitHub Pages with Travis CI 블로그 구축기 2 Using Travis CI to publish to GitHub pages with custom domain 저처럼 Gtihub Page에 blog.burt.pe.kr 이라는 커스텀 도메인을 연결해 사용할 때, Travis-ci 로 배포를 하면 매번 커스텀 도메인 설정이 Reset되는 문제점이 있습니다.</description></item><item><title>디지털 비디오 기술 이해하기</title><link>https://blog.burt.pe.kr/posts/digital-video-tech/</link><pubDate>Fri, 01 Dec 2017 18:31:34 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/digital-video-tech/</guid><description>[001]
동영상 인코딩이 무엇이고 왜하고 어떻게 하는지 살펴 보겠습니다. [002]
강의 Github repo는 https://github.com/leandromoreira/digital_video_introduction 입니다. 제안해 주실 의견이 있다면 주십시오. 언제든지 환영합니다. 컴퓨터를 잘 알고 특히 오디오와 비디오에 대해 잘 아는 분에게는 처음 부분이 지루할 수 있습니다. 그러나 어느 부분에 이르면 반드시 도움이 될 내용을 찾을 수 있을 것입니다. [003]
시작해 봅시다. [004]
우리는 이미지를 단순한 2차원 정수 배열로 볼 수 있습니다. 회색인 경우 1개의 평면만 필요하고 컬러인 경우 더 많은 평면을 사용해 3차원 배열을 만듭니다.</description></item><item><title>OOP와 POP(Protocol Oriented Programming)</title><link>https://blog.burt.pe.kr/posts/protocol-oriented-programming/</link><pubDate>Thu, 18 May 2017 19:03:14 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/protocol-oriented-programming/</guid><description>Swift 2.0 출시 이후, 스위프트 개발자들 사이에서 POP가 화두가 되어 왔습니다. POP는 Protocol Oriented Programming 약자입니다. OOP는 Object Oriented Programming 약자입니다. POP는 뜻 그대로 프로토콜 중심 프로그래밍이고 OOP는 객체 중심 프로그래밍입니다. POP와 OOP 차이가 무엇일까요? 차이가 무엇이길래 개발자들 사이에서 화두가 되고 있을까요?
답을 생각해 보기 전에 OOP의 핵심이 무엇인지 알아야 합니다. OOP 핵심은 상속입니다. 상속을 통해 타입을 확장합니다. 하지만 여러 객체로부터 상속해야 할 경우 많은 문제가 발생합니다. 단일 상속이어도 클래스 상속 계층이 깊어질수록 문제가 커집니다.</description></item><item><title>A* 데모 프로그램</title><link>https://blog.burt.pe.kr/posts/astar-story/</link><pubDate>Sat, 23 Jan 2010 18:19:21 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/astar-story/</guid><description>알림 이 글은 제 네이버 블로그 에서 아카이빙을 위해 가져온 글입니다. 그 당시 svn 같은 소스 관리툴을 사용하지 않아서 코드 히스토리를 남기지 못한게 아쉽네요.
github https://github.com/skyfe79/AStar
J모 게임 회사에 면접을 볼 때 만들었던 Astar 데모 프로그램. 다른 회사에 오긴 했지만 만들면서 꽤 재미있는 시간을 보낸 기억이&amp;hellip; 지금은 HPA* HAA* 등을 공부하면서 항상 개선점이 발생하고 해결하면서 멋진 솔루션이 탄생함을 깨닫는다. 이런 개선점과 해결방법을 고민하는 자세를 가져야겠다.</description></item><item><title>SGL:소프트웨어 3D 렌러러 이야기</title><link>https://blog.burt.pe.kr/posts/sgl-story/</link><pubDate>Tue, 01 Dec 2009 18:10:13 +0900</pubDate><guid>https://blog.burt.pe.kr/posts/sgl-story/</guid><description>알림 이 글은 제 네이버 블로그 에서 아카이빙을 위해 가져온 글입니다. 그 당시 svn 같은 소스 관리툴을 사용하지 않아서 코드 히스토리를 남기지 못한게 아쉽네요.
github https://github.com/skyfe79/SGL
소프트웨어렌더러를 만들어 보자고 생각한 건 1년 전 쯤이었습니다. 게임 엔진 개발자를 꿈꾸는 저에게 소프트웨어 렌더러는 반드시 넘어야 할 첫 관문이라고 여겼기 때문이죠. 1년여의 시간동안 시간날 때마다 틈틈히 만들어 온 것이 구현하고자 했던 목표를 다 구현하게 되었습니다. 1년동안 프로젝트를 하면서 많은 정이 든 프로젝트이고 (도대체 갈아 엎기를 몇 번 ?</description></item></channel></rss>